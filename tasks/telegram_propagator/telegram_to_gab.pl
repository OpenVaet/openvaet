#!/usr/bin/perl
use strict;
use warnings;
use 5.26.0;
no autovivification;
binmode STDOUT, ":utf8";
use utf8;
use POSIX;
use URI::Escape;
use HTTP::Request;
use HTTP::Cookies;
use HTML::Tree;
use LWP::UserAgent;
use LWP::Simple;
use Data::Printer;
use Data::Dumper;
use File::Path qw(make_path);
use WWW::Telegram::BotAPI;
use JSON;

=head
    ----------------------------------------
    CONFIGURATION FOR TELEGRAM API
    ________________________________________
    1. Get to https://t.me/BotFather
    2. Type /newbot and register a name & username for the bot in order to get a Telegram Token.
    3. Put your Telegram Token in the .cfg file.
    4. Back to BotFather, type /setprivacy, and enter your bot alias (@bot_name).
    5. Choose "Disable" so the bot can read group messages.
    6. Invite your Bot to your channel as Administrator.


    ----------------------------------------
    CONFIGURATION FOR Gab Posting
    ________________________________________
    1. Put your credentials in the tasks/telegram_propagator/config.cfg file.
=cut

# Fetches config data from file.
my $configurationFile = 'tasks/telegram_propagator/config.cfg';
my %config            = ();
get_config();
my $telegramToken     = $config{'telegramToken'}   // die;
my $gabAlias          = $config{'gabAlias'}        // die;
my $gabUserName       = $config{'gabUserName'}     // die;
my $gabUserPassword   = $config{'gabUserPassword'} // die;

# Initiates UserAgent.
my $cookie = HTTP::Cookies->new();
my $ua     = LWP::UserAgent->new
(
    timeout    => 30,
    cookie_jar => $cookie,
    agent      => 'Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.90 Safari/537.36'
);

# Initiates Gab session.
my ($gabAuthToken, $gabUriAuthToken, $gabToken);
init_gab_session();

# Initiates Telegram API.
my $telegramApi = WWW::Telegram::BotAPI->new (
    token => $telegramToken
);

# Initiates Telegram watching loop.
my %messages = ();
while (1) {
    %messages = ();
    
    # Gets the Telegram updates.
    get_telegram_updates();

    # Prints the posts content (mainly for debug purposes in this early version).
    print_telegram_updates();
    sleep 5;
}

sub get_config {
    die "missing file [$configurationFile]" unless -f $configurationFile;
    my $json = json_from_file($configurationFile);
    %config  = %$json;
}

sub json_from_file {
    my $file = shift;
    if (-f $file) {
        my $json;
        eval {
            open my $in, '<:utf8', $file;
            while (<$in>) {
                $json .= $_;
            }
            close $in;
            $json = decode_json($json) or die $!;
        };
        if ($@) {
            {
                local $/;
                open (my $fh, $file) or die $!;
                $json = <$fh>;
                close $fh;
            }
            eval {
                $json = decode_json($json);
            };
            if ($@) {
                die "failed parsing json : " . @!;
            }
        }
        return $json;
    } else {
        return {};
    }
}

sub init_gab_session {

    # First of all, we need a token which is randomly generated by Gab when a user initiates a session
    $gabAuthToken    = get_gab_home();

    # Second, we need to convert the token to URI compatible format. We may need to also convert passwords with special characters the same way.
    $gabUriAuthToken = uri_escape($gabAuthToken);

    # We then login to Gab, and retrieve the User token which will allow us to Post.
    login_gab();
    $gabToken        = get_gab_token();
}

sub print_log {
    my $message = shift;
    my $currentDatetime = current_datetime();
    open my $out, '>>:utf8', 'tasks/telegram_propagator/telegram_bot_logs.txt';
    say "$currentDatetime - $message";
    say $out "$currentDatetime - $message";
    close $out;
}

sub current_datetime
{
    my $currentDatetime = strftime "%Y-%m-%d %H:%M:%S", localtime time;
    return $currentDatetime;
}

sub get_gab_home {
    print_log("Getting Gab Authenticity Token ...");
    my $url     = "https://gab.com/";
    my $res     = $ua->get($url);
    my $content = $res->decoded_content;
    my $tree    = HTML::Tree->new();
    $tree->parse($content);
    my $meta    = $tree->look_down(name=>"csrf-token");
    my $authenticityToken = $meta->attr_get_i('content');
    return $authenticityToken;
}

sub login_gab {
    print_log("Initiating Gab session ...");
    my @headers = (
        ':Authority'                => 'gab.com',
        ':Method'                   => 'POST',
        ':Path'                     => '/auth/sign_in',
        ':Scheme'                   => 'https',
        'Accept'                    => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8',
        'Accept-Encoding'           => 'gzip, deflate',
        'Accept-Language'           => 'en-US,en;q=0.9',
        'Cache-Control'             => 'max-age=0',
        'Connection'                => 'keep-alive',
        'Content-Type'              => 'application/x-www-form-urlencoded',
        'Origin'                    => 'https://gab.com',
        'Referer'                   => "https://gab.com/auth/sign_in",
        'sec-ch-ua'                 => 'Google Chrome";v="105", "Not)A;Brand";v="8", "Chromium";v="105"',
        'Sec-Fetch-Dest'            => 'document',
        'Sec-Fetch-Mode'            => 'navigate',
        'Sec-Fetch-Site'            => 'same-origin',
        'Sec-Fetch-User'            => '?1',
        'Sec-GPC'                   => 1,
        'TE'                        => 'trailers',
        'Upgrade-Insecure-Requests' => 1,
        'User-Agent'                => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36'
    );
    my $url     = "https://gab.com/auth/sign_in";
    my $request = new HTTP::Request( 'POST', $url);
    my $params  = "authenticity_token=$gabUriAuthToken&user[email]=$gabUserName&user[password]=$gabUserPassword&button=";
    $request->header(@headers);
    $request->content($params);
    my $res     = $ua->request($request);
    my $content = $res->decoded_content;
    my $tree    = HTML::Tree->new();
    $tree->parse($content);
    my $text    = $tree->find('body')->as_trimmed_text;
    if ($text eq 'You are being redirected.') {
        print_log("Login to Gab successfull ...");
        return 1;
    } else {
        print_log("Login to Gab failed, verify your configuration file and contact openvaet.org if required.");
        die;
    }
}

sub get_gab_token {
    print_log("Getting Gab User Token ...");
    my $url      = "https://gab.com/$gabAlias";
    my $res      = $ua->get($url);
    my $content  = $res->decoded_content;
    my $tree     = HTML::Tree->new();
    $tree->parse($content);
    my $initSet  = $tree->look_down(id=>"initial-state");
    my $asHTML   = $tree->as_HTML('<>&', "\t");
    my ($json)   = $asHTML =~ /<script id="initial-state" type="application\/json">(.*)<\/script>/;
    $json        = decode_json($json);
    my $gabToken = %$json{'meta'}->{'access_token'} // die;
    return $gabToken;
}

sub post_on_gab {
    my ($channelId, $messageId) = @_;
    print_log("Re-posting on Gab Telegram message [$channelId -> $messageId] ...");
    my $file = "telegram_data/$channelId/$messageId/message.json";
    open my $in, '<:utf8', $file;
    my $json;
    while (<$in>) {
        $json .= $_;
    }
    close $in;
    $json = decode_json($json);
    print_log("Retrieved Telegram message ...");

    # If we have a document attachment, we verify its a video, and proceed with uploading.
    my @mediaIds;
    if (%$json{'documents'}) {
        for my $file (@{%$json{'documents'}}) {
            my @elems = split '\.', $file;
            my $ext   = $elems[scalar @elems - 1] // die;
            if ($ext eq 'mp4' || $ext eq 'jpg') {
                my $mediaId = upload_gab_media($file);
                push @mediaIds, $mediaId;
            } else {
                die "File type to review : [$ext]";
            }
        }
    }
    my $text = %$json{'text'};
    my @headers = (
        ':Authority'                => 'gab.com',
        ':Method'                   => 'POST',
        ':Path'                     => '/auth/sign_in',
        ':Scheme'                   => 'https',
        'Accept'                    => 'application/json, text/plain, */*',
        'Accept-Encoding'           => 'gzip, deflate, br',
        'Accept-Language'           => 'en-US,en;q=0.9',
        'Authorization'             => "Bearer $gabToken",
        'Cache-Control'             => 'max-age=0',
        'Connection'                => 'keep-alive',
        'Content-Type'              => 'application/json;charset=utf-8',
        'Origin'                    => 'https://gab.com',
        'Referer'                   => "https://gab.com",
        'sec-ch-ua'                 => 'Google Chrome";v="105", "Not)A;Brand";v="8", "Chromium";v="105"',
        'Sec-Fetch-Dest'            => 'empty',
        'Sec-Fetch-Mode'            => 'cors',
        'Sec-Fetch-Site'            => 'same-origin',
        'Sec-Fetch-User'            => '?1',
        'Sec-GPC'                   => 1,
        'TE'                        => 'trailers',
        'Upgrade-Insecure-Requests' => 1,
        'User-Agent'                => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36',
        'X-CSRF-Token'              => $gabAuthToken
    );
    my $url     = "https://gab.com/api/v1/statuses";
    my $request = new HTTP::Request( 'POST', $url);
    my %params  = ();
    $params{'expires_at'}     = undef;
    $params{'group_id'}       = undef;
    $params{'in_reply_to_id'} = undef;
    $params{'markdown'}       = $text;
    $params{'media_ids'}      = \@mediaIds;
    $params{'poll'}           = undef;
    $params{'quote_of_id'}    = undef;
    $params{'scheduled_at'}   = undef;
    $params{'sensitive'}      = 'false';
    $params{'spoiler_text'}   = '';
    $params{'status'}         = $text;
    $params{'visibility'}     = 'public';
    my $params = encode_json\%params;
    $request->header(@headers);
    $request->content($params);
    my $res     = $ua->request($request);
    my $content = $res->decoded_content;
    print_log("Successfully Posted Message to Gab ...");
}

sub upload_gab_media {
    my ($file) = @_;
    print_log("Uploading file [$file] to Gab ...");
    my @int = ('0' ..'9');
    my $randString30 = join '' => map $int[rand @int], 1 .. 30;
    my @headers = (
        'Accept'                    => 'application/json, text/plain, */*',
        'Accept-Encoding'           => 'gzip, deflate',
        'Accept-Language'           => 'en-US,en;q=0.9',
        'Authorization'             => "Bearer $gabToken",
        'Connection'                => 'keep-alive',
        'Content-Type'              => "multipart/form-data; boundary=-----------------------------$randString30",
        'Host'                      => 'gab.com',
        'Origin'                    => 'https://gab.com',
        'Referer'                   => "https://gab.com/",
        'Sec-Fetch-Dest'            => 'empty',
        'Sec-Fetch-Mode'            => 'cors',
        'Sec-Fetch-Site'            => 'same-origin',
        'Sec-GPC'                   => 1,
        'User-Agent'                => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36',
        'X-CSRF-Token'              => $gabAuthToken
    );
    my $url     = "https://gab.com/api/v1/media";
    my @elems   = split '\/', $file;
    my $name    = $elems[scalar @elems - 1] // die;
    my $request = HTTP::Request::Common::POST(
      $url, @headers,
      Content       => [ file => [$file] ],
    );
    my $res     = $ua->request($request);
    my $content = $res->decoded_content;
    my $json    = decode_json($content);
    my $type    = %$json{'type'};
    unless ($type) {
        print_log("Failed uploading file [$file] to Gab ...");
        die;
    }
    print_log("Success uploading [$file] to Gab ...");
    return %$json{'id'};
}

sub get_telegram_updates {
    print_log("Getting Telegram Channels Last Updates ...");
    my $offset      = -30;
    my $updates     = $telegramApi->getUpdates ({
        timeout => 10,
        $offset ? (offset => $offset) : ()
    });
    if (%$updates{'result'}) {
        for my $result (@{%$updates{'result'}}) {
            if (%$result{'channel_post'}) {
                my $channelId = %$result{'channel_post'}->{'chat'}->{'id'} // die;
                $channelId    =~ s/\-//;
                my $uts       = %$result{'channel_post'}->{'date'} // die;
                my $messageId = %$result{'channel_post'}->{'message_id'} // die;
                my $text      = %$result{'channel_post'}->{'text'} // %$result{'channel_post'}->{'caption'};
                my $mediaGroupId = %$result{'channel_post'}->{'media_group_id'};
                if ($mediaGroupId) {
                    $messageId = $mediaGroupId;
                }
                $messages{$channelId}->{$messageId}->{'uts'}       = $uts;
                $messages{$channelId}->{$messageId}->{'text'}      = $text if $text;
                if (%$result{'channel_post'}->{'document'}) {
                    my $fileId   = %$result{'channel_post'}->{'document'}->{'file_id'}   // die;
                    my $fileName = %$result{'channel_post'}->{'document'}->{'file_name'} // die;
                    my $fileDetails = $telegramApi->getFile({file_id => $fileId});
                    my $filePath  = %$fileDetails{'result'}->{'file_path'} // die;   
                    my $fileUrl   = "https://api.telegram.org/file/bot$telegramToken/$filePath";
                    my $localFolder = "telegram_data/$channelId/$messageId/documents";
                    make_path($localFolder) unless (-d $localFolder);
                    my $localFile = "$localFolder/$fileName";
                    unless (-f $localFile) {
                        my $rc = getstore($fileUrl, $localFile);
                        if (is_error($rc)) {
                            die "getstore of <$fileUrl> failed with $rc";
                        }
                    }
                    push @{$messages{$channelId}->{$messageId}->{'documents'}}, $localFile;
                }
                if (%$result{'channel_post'}->{'photo'}) {
                    my $localFolder = "telegram_data/$channelId/$messageId/documents";
                    make_path($localFolder) unless (-d $localFolder);
                    $messages{$channelId}->{$messageId}->{'fNum'}++;
                    my $fNum = $messages{$channelId}->{$messageId}->{'fNum'} // die;
                    my $fileId;
                    for my $photo (@{%$result{'channel_post'}->{'photo'}}) {
                        $fileId   = %$photo{'file_id'}   // die;
                    }
                    my $fileDetails = $telegramApi->getFile({file_id => $fileId});
                    my $filePath = %$fileDetails{'result'}->{'file_path'} // die;   
                    my $fileUrl  = "https://api.telegram.org/file/bot$telegramToken/$filePath";
                    my @elems = split '\.', $fileUrl;
                    my $ext = $elems[(scalar @elems - 1)] // die;
                    my $localFile = "$localFolder/$fNum.$ext";
                    push @{$messages{$channelId}->{$messageId}->{'documents'}}, $localFile;
                    unless (-f $localFile) {
                        my $rc = getstore($fileUrl, $localFile);
                        if (is_error($rc)) {
                            die "getstore of <$fileUrl> failed with $rc";
                        }
                    }
                }
            } else {
                say "Unknown result type";
                p$result;
            }
        }
    }
}

sub print_telegram_updates {
    for my $channelId (sort{$a <=> $b} keys %messages) {
        for my $messageId (sort{$a <=> $b} keys %{$messages{$channelId}}) {
            my $localFolder = "telegram_data/$channelId/$messageId";
            make_path($localFolder) unless (-d $localFolder);
            unless (-f "$localFolder/message.json") {
                my %obj = %{$messages{$channelId}->{$messageId}};
                open my $out, '>:utf8', "$localFolder/message.json";
                print $out encode_json\%obj;
                close $out;
                post_on_gab($channelId, $messageId);
            }
        }
    }
}